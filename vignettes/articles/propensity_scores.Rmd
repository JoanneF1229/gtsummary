---
title: "Propensity Score Analysis"

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction

RCT are considered the goal standard approach for estimating treatment effects.
Random allocation ensures that treatment assignment will not be confounded by either measured or unmeasured baseline characteristics. In observational or non-randomized studies, treatment selection is often accompanied by subject characteristics.
Propensity score (PS) is one approach to reduce the effects of confounding in observational studies. 
PS is therefore a balancing score. Conditional on PS, the distribution of observed baseline characteristics will be similar between treated and untreated subjects.

## Useful recources and vignettes 

For those who want to have deeper understanding of causal inference, please visit the causal inference R workshop prepared by Malcolm Barrett ([@malco_barrett](https://twitter.com/malco_barrett)) & Lucy Dâ€™Agostino McGowan ([@LucyStats](https://twitter.com/LucyStats)):
https://github.com/malcolmbarrett/causal_inference_r_workshop

Additional useful vignettes include by not limited to

- Matching weights tutorial: http://rstudio-pubs-static.s3.amazonaws.com/198545_5fae2128569a4e4a80627bc87c71d1e2.html

- SAS 'PSMATCH" procedure:https://support.sas.com/rnd/app/stat/procedures/psmatch.html

- A review of propensity score: principles, methods and application in Stata:https://www.stata.com/meeting/italy14/abstracts/materials/it14_grotta.pdf
<br>

## Data

Using the National Health and Nutrition Examination Survey Data (`nhefs_complete`), we are interested in the relationship between the **exposure**, `qsmk`, whether the participant quit smoking, and the **outcomes** : 1) `death`: whether the participate died or not as binary outcome, 2) time to death as time to event outcome, and 3) `wt82_71`, weight change in kilograms as continuous outcome 

Some possible confounders: 
`sex`, `age`,`smokeyrs`,`sbp`,`dbp`,`race`,`income`,`diabetes`,`exercise`,`income` and `wt71` 

```{r, eval = FALSE}
install.packages(c("gtsummary", "tidyverse" "remotes"))
```

```{r setup, echo = FALSE, message=FALSE}
library(gtsummary)
library(tidyverse)
library(survival)

theme_gtsummary_compact()

nhefs <- 
  causaldata::nhefs_complete %>%
  mutate(
    os.yrs =
      case_when(
        death == 1 ~ as.numeric(yrdth - age),
        death == 0 ~ 21
      ),
    exercise = 
      factor(exercise, 
             levels = c(0, 1, 2), 
             labels = c("A lot", "Moderate", "Little")),
    across(c(race, sex), ~as.numeric(as.character(.)))
  ) %>%
  select(seqn, qsmk, sbp, dbp, sex, age, race, wt71, 
         smokeyrs, exercise, wt82_71, os.yrs, death) %>%
  drop_na() %>%
  labelled::set_variable_labels(
    sbp = "Systolic Blood Pressure",
    dbp = "Diastolic Blood Pressure",
    sex = "Female",
    age = "Age",
    race = "African American",
    wt71 = "Weight, kg",
    smokeyrs = "Smoking Years",
    exercise = "Exercise Amount"
  )
```

## Steps to consider prior to matching  

Use `tbl_summary` to examine collected baseline characteristics between treated and un-treated groups

SMD (standardized mean difference) is the most commonly used statistic to examine balance diagnostics https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6351359/

Variables with abs(SMD) > 0.1 is indicative of data imbalance between the groups.   
Use `add_difference()` and `method`= smd to compute the SMD between the two groups.  SMD is calculated using the `smd()` function in package `smd`. 

From the summary table, all the variables have SMD>0.1 and this suggests imbalanced between baseline characteristics and the groups that did and did not quit smoking. In addition, we also didn't compute SMD for any outcomes variable -use  `include()` to omit.


```{r pre_match_smd}
gts_pre_match <-
  nhefs %>%
  select(-c(seqn, os.yrs, death, wt82_71)) %>%
  mutate(
    qsmk = 
      factor(qsmk, 
             levels = c(0, 1), 
             labels = c("Did _not_ Quit Smoking", "Quit Smoking"))
  ) %>%
  tbl_summary(
    by = qsmk,
    statistic = list(all_continuous() ~ "{mean} ({sd})",
                     all_dichotomous() ~ "{p}%")
  ) %>%
  add_difference(everything() ~ "smd") %>%
  modify_header(
    estimate ~ "**SMD**", # rename Difference to SMD
    all_stat_cols() ~ "**{level}**<br>N = {n}"
  ) %>%
  modify_column_hide(columns = ci) # remove 95% CI

# Extract the SMD pre-matching
pre_match_smd <-
  gts_pre_match$table_body %>%
  select(variable, label, smd = estimate) %>%
  drop_na()

gts_pre_match
```

## Constructing PS score

Logistic regression model is the most common method to construct the propensity score to predict the probability of receiving the treatment

```{r Pscore}
# Construct PS model
mod_ps <- 
  glm(
    qsmk ~ sbp + dbp + sex + age + race + wt71 + smokeyrs + exercise,
    data = nhefs, 
    family = binomial
  )

## Summarize the PS findings
mod_ps %>%
  tbl_regression(exponentiate = TRUE) %>%
  modify_caption("**Factors associated with quitted smoking**")
```

```{r warning=FALSE}
## To explorer the overlapping regions
df_with_ps <- 
  ## obtained the estimated PS
  broom::augment(
    mod_ps, 
    type.predict = "response"
  ) %>%
  bind_cols(nhefs %>% select(seqn), .) %>%
  rename(ps_score = .fitted)

# mirrored histograms
ggplot() +
  geom_histogram(
    data = df_with_ps %>% filter(qsmk == 1), 
    aes(ps_score, y = ..count.., fill = "Quit Smoking"),
    bins = 40
  ) +
  geom_histogram(
    data = df_with_ps %>% filter(qsmk == 0), 
    aes(ps_score, y = -..count.., fill = "Did not Quit Smoking"),
    bins = 40
  ) +
  labs(
    fill = "Group",
    x = "Probability of Quitting"
  ) +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(label = abs, n.breaks = 6) +
  theme_bw() +
  theme(legend.position = "bottom")
```

Before applying the estimated PS (either through matching, stratification or inverse probability weight), it is important to examine the region of common support.
If the two groups do not have sufficient common region (i.e, the distributions  are total mirror imaging of each other), then applying PS analysis may not be feasible. 

## PS Matching

There are different algorithm for matching: optimal matching (Bersekas, 1991), Greedy's nearest neighbour matching (with or without replacement). See Austin (2012) for detailed discussion and comparison of different algorithms for matching on the propensity score. The R pckage `MatchIt` written by Noah Greifer, offers different methods for matching. Complete vignette on this package can be found here: https://cran.r-project.org/web/packages/MatchIt/vignettes/MatchIt.html#assessing-the-quality-of-matches]

The following codes show the 1:1 Greedy's nearest neighbour matching without replacement with a caliper of 0.25. 

Caliper is the actual maximum distance allowed by the matching algorithm. It is usually set to be a quarter of standard deviation of the propensity score. Reference on selecting the appropriate caliper canbe found here : https://doi.org/10.1093/aje/kwt212

```{r match}
df_matchit_results <-
  MatchIt::matchit(
    qsmk ~ sbp + dbp + sex + age + race + wt71 + smokeyrs + exercise,
    data = nhefs,
    method = "nearest",
    distance = "glm",
    link = "logit",
    caliper = 0.25, # starting typically with 0.25
    std.caliper = TRUE,
    replace = FALSE
  )

# Extract matched data for analysis
df_post_match <- MatchIt::match.data(df_matchit_results)
```

## Summarize the matching

After matching, we can use `tbl_summary()` to assess the balance of covariates between the matched group. Alternative way is to use the mirrored histograms to review the distributions of propensity score for the matched and unmatched groups.

### Post-matching SMD

We now see the distributions are fairly balanced between the two groups and abs(SMD) are all below 0.1.

```{r postmatchSMD}
gts_post_match <-
  df_post_match %>%
  select(sbp, dbp, sex, age, race, wt71, smokeyrs, exercise, qsmk) %>%
  mutate(
    qsmk = 
      factor(qsmk, 
             levels = c(0, 1), 
             labels = c("Did _not_ Quit Smoking", "Quit Smoking"))
  ) %>%
  tbl_summary(by = "qsmk") %>%
  add_difference(
    test = everything() ~ "smd",
    estimate_fun = ~partial(style_sigfig, digits = 3)
  ) %>%
  modify_header(estimate ~ "**SMD**") %>% # rename Difference to SMD
  modify_column_hide(columns = ci) # remove 95%CI

# Extract the SMD
post_match_smd <- 
  gts_post_match$table_body %>%
  select(variable, label, smd = estimate) %>%
  drop_na()

gts_post_match
```

### Plot showing the balance effect of matching

```{r}
pre_match_smd %>% 
  mutate(type = "Pre-Match") %>%
  bind_rows(post_match_smd %>% mutate(type = "Post-Match")) %>%
  mutate(smd = abs(smd)) %>%
  ggplot(aes(x = label, y = smd, group = type, color = type)) +
  geom_point(size = 2) +
  geom_hline(yintercept = 0.1, color = "black", 
             size = 0.1, linetype = "dashed") +
  labs(y = "SMD", x = NULL, group = NULL, color = NULL) +
  coord_flip() +
  theme_bw() +
  theme(legend.position = "bottom")
```

#### Visualize the distributions of PS for the matching groups

```{r warning=FALSE}
df_with_ps %>%
  select(seqn, qsmk, ps_score) %>%
  mutate(group = "Unmatched") %>%
  rows_update(
    df_post_match %>%
      select(seqn, qsmk) %>%
      mutate(group = "Matched"),
    by = "seqn"
  ) %>%
  mutate(
    qsmk = 
      factor(qsmk, 
             levels = c(0, 1), 
             labels = c("Did not Quit Smoking", "Quit Smoking"))
  ) %>%
  ggplot() +
  geom_histogram(
    data = ~filter(.x, qsmk == "Quit Smoking"),
    aes(x = ps_score, y = ..count..),
    fill = "grey40", color = NA, bins = 40
  ) +
  geom_histogram(
    data = ~filter(.x, qsmk == "Quit Smoking", group == "Matched"),
    aes(x = ps_score, y = ..count.., fill = qsmk),
    color = NA, bins = 40
  ) +
  geom_histogram(
    data = ~filter(.x, qsmk == "Did not Quit Smoking"),
    aes(ps_score, y = -..count..),
    fill = "grey40", color = NA, bins = 40
  ) +
  geom_histogram(
    data = ~filter(.x, qsmk == "Did not Quit Smoking", group == "Matched"),
    aes(ps_score, y = -..count.., fill = qsmk),
    color = NA, bins = 40
  ) +
  scale_y_continuous(labels = abs, n.breaks = 6) +
  scale_x_continuous(n.breaks = 6, limits = c(0, 1)) +
  labs(fill = NULL, x = "Propensity Score") +
  theme(legend.position = "bottom")
```

Mirrored histograms again are helpful to view the distribution of PS for the matched (colored) and unmatched (gray) of the control and treated groups.
This is a helpful visualization to show if the  unmatched were very different between cases and controls

### Strategy to improve balance between groups 

Parameters within matchit can be tweaked to help improve matching.

- For example, relaxing or tightening the maximum caliper width will affect how closely the pairs are matched may improve the overall balance.

- Choosing a different matching algorithm, for example, the default is to match the largest (`m.order` = "largest") matching takes place in descending order of distance measures.

- Re-specify the PS model with additional covarites

If matching does not improve, consider a different matching strategy.
Below we will show the matching weights methods.  

## Matching weights (uses package Matching)

The matching weights method is a weighting analogue to the 1:1 pairwise matching (https://pubmed.ncbi.nlm.nih.gov/23902694/). 

The concept of matching weights is similar to the inverse probability treatment weight.
The propensity score matching weight is defined as the smaller of the predicted probabilities of receiving or not receiving the treatment over the predicted probability of being assigned to the arm the patient is actually in. 

Use `svydesign` to specify the matching weights

```{r}
library(Matching)

## Using the complete case data and fitted propensity model constructed above
dat <- nhefs # Quit Smoke is 1
psModel <- mod_ps


## Predicted probability of being assigned to group1
dat$pgrp1 <- predict(psModel, type = "response")
## Predicted probability of being assigned to group2
dat$pgrp2 <- 1 - dat$pgrp1

## Predicted probability of being assigned to the
## treatment actually assigned (either group1 or group2)
dat$pAssign <- NA
dat$pAssign[dat$qsmk == 1] <- dat$pgrp1[dat$qsmk == 1]
dat$pAssign[dat$qsmk == 0] <- dat$pgrp2[dat$qsmk == 0]

## Smaller of pgrp1 vs pgrp2 for matching weight
dat$pMin <- pmin(dat$pgrp1, dat$pgrp2)

## Propensity score matching weight
dat$mw <- dat$pMin / dat$pAssign

## Weighted data
datSvy <- survey::svydesign(ids = ~1, data = dat, weights = ~mw)
```

## Post-matching weights SMD

Use `tbl_svysummary` to summarize the match weighted data and calculate SMD.  



```{r}

datSvy %>%
  tbl_svysummary(
    by = "qsmk",
    include = c(sbp, dbp, sex, age, race, wt71, smokeyrs, exercise)
  ) %>%
  add_difference(
    test = everything() ~ "smd",
    estimate_fun = ~partial(style_sigfig, digits = 3)
  ) %>%
  modify_header(estimate ~ "**SMD**") %>%   # rename Difference to SMD
  modify_column_hide(columns = ci)          # remove 95%CI
```


Note that effective sample sizes were rounded to whole numbers for convenience but should not be interpreted as the number of patients because  some patient may only be contributing a portion of his/her information.  Therefore, the focus should be on the comparison of percentages in each exposure group.   



## Outcome analysis
More details on estimating effect after matching can be found here: https://kosukeimai.github.io/MatchIt/articles/estimating-effects.html

Below are some example codes on estimating treatment effect after propensity score 1:1 matching
### PS 1:1 matched  


#### For continuous outcome

```{r}
# Continuous outcome weight changes
fit1 <- lm(wt82_71 ~ qsmk,
           data = df_post_match, weights = weights
)

# Cluster-robust standard errors
lmtest::coeftest(fit1, cluster = ~subclass)
```




#### For binary outcome
```{r}

# Binary outcome
glm(death ~ qsmk,
    family = binomial,
    data = df_post_match, weights = weights
) %>% tbl_regression(exponentiate = TRUE)
```

#### Survival outcome
```{r}
# Cox Regression for marginal HR-Estimating using the cluster robust standard error
coxMatchedclust <- coxph(Surv(os.yrs, death) ~ qsmk,
                         robust = TRUE,
                         weights = weights,
                         cluster = subclass,
                         data = df_post_match
) %>% tbl_regression(exponentiate = TRUE)


# Frailty model
coxMatchedfrail <- coxph(Surv(os.yrs, death) ~ qsmk + frailty(subclass),
                         data = df_post_match
) %>% tbl_regression(exponentiate = TRUE, include = qsmk)

tbl_merge(list(coxMatchedclust, coxMatchedfrail),
          tab_spanner = c("**Marginal HR model**", "**Frailty model**")
)
```



### Matching weights

#### Continuous outcome
```{r}
glmWeighted1 <- survey::svyglm(wt82_71 ~ qsmk,
                               family = gaussian(link = "identity"),
                               design = datSvy
)

lmtest::coeftest(glmWeighted1, cluster = ~subclass)
```




#### Binary outcome
```{r}
glmWeighted <- survey::svyglm(death ~ qsmk,
                              family = quasibinomial(),
                              design = datSvy
)

tbl_regression(glmWeighted, exponentiate = TRUE)
```


#### Survival outcome
```{r}
coxWeighted <- survey::svycoxph(Surv(os.yrs, death) ~ qsmk,
                                design = datSvy
)

tbl_regression(coxWeighted, exponentiate = TRUE)
```




## Conclusions
Matching often involves a trade-off among balance, generalization, and sample size. The main advantage of the propensity score matching is it allows the researchers to design and estimate the average treatment effect in the treated from observational or non-randomized study by forming balanced matched pairs that share the similarly value of the propensity score and minimizing the effect of confounding due to non-random allocation of treatment. However, some concerns of PSM includes but not limited to 1) requires large samples with substantial overlap in PS between treated and control; 2) More tweaking is needed by user to achieve balance; 3) PSM can only accounts for observed (observable) covariates and not latent characteristics. 

Matching weights can offer a more efficient estimation and more accurate variance calculation.  It achieves balance with little tweaking required by user. It uses data from all patients, with no exclusion due to difficulty of matching but patients at the extreme end of the PS spectrum are being down-weighted and contribute very little to the final estimation.
Therefore, the matched sample is considered a pseudo-population where patients are only contributing a portion of their data.  This concept may be challenging to understand for investigators.
